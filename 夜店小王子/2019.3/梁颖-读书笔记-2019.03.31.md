
#Android 资源文件夹限定符命名及获取规则
##创建限定符文件夹
使用Android studio 自带的工具进行创建, 参考下图
  
![](https://i.imgur.com/yG70yLO.png)  

其中 Available qualifiers 即为支持的所有限定符，用户可以选中多个限定符，生成类似 values-zh-ldltr-sw360dp-xxhdpi-360x640 这种文件夹
##限定符优先级  
按照如下顺序排列（其实就是上图中创建限定符文件夹时studio列出的顺序）
  
 - （移动国家代码）
 - （语言和区域）
 - （布局方向）
 - （smallestWidth）
 - （可用宽度）
 - （可用高度）
 - （屏幕尺寸）
 - （屏幕纵横比）
 - （圆形屏幕）
 - （屏幕方向）
 - （UI 模式）
 - （夜间模式）
 - （屏幕像素密度 ）
 - （.....）
 - （屏幕绝对尺寸dp）
 - （API级别）
##系统读取限定符文件夹的顺序  
**查找顺序** 

1.  根据高到底的限定符优先级顺序开始检索文件夹（根据上面的优先级开始查找）
2.  如果检索到匹配限定符，且此限定符不是像素密度限定符，则将该限定符属性与设备属性冲突的文件夹排除
     - 理解  
     比如第一优先级是移动国家代码，移动国家代码包含 MCC和 MNC 如果匹配到了 MCC 则将含有 MNC 的文件夹排除，但是在像素密度限定符上除外 比如设备是 XXhdpi 不会将 mdpi 排除
     - 举例  
     drawable-fr-rCA/ 目录与 en-GB 语言区域冲突，因而被淘汰。

		>drawable/  
drawable-en/  
drawable-fr-rCA/（淘汰）  
drawable-en-port/  
drawable-en-notouch-12key/  
drawable-port-ldpi/  
drawable-port-notouch-12key/  
3. 如果检索到匹配限定符，且此限定符不是像素密度限定符，则将不含该限定符的文件夹跳过 如果没有检索到，则按照优先级顺序进行下一个限定符的检索  
     - 举例
		>drawable/（跳过）  
drawable-en/  
drawable-en-port/  
drawable-en-notouch-12key/  
drawable-port-ldpi/（跳过）  
drawable-port-notouch-12key/（跳过）
4. 返回并重复第 第 3 步和第 4 步，直到只剩下一个目录为止。在此示例中，屏幕方向是下一个判断是否匹配的限定符。因此，未指定屏幕方向的资源被跳过：
	>drawable-en/（跳过）  
drawable-en-port/  
drawable-en-notouch-12key/（跳过）
5. 例如：
     - 当满足一级为B级的限定符但不满足B级后面的C级限定符时则淘汰该BC文件夹 
     - 如果B级下面的所有所有C级均已经被淘汰且不存在单独的一级为B的文件夹，则直接进入一级为C级的限定符（其实就是下一个优先级的限定符）进行限定，抛弃所有一级为B限定符文件夹  

	在此示例中 en限定符级别高于sw限定符 系统优先进入en下匹配，进入en后在进入屏幕尺寸限定符，但sw360不符合设备配置，且当前就不存在单独的drawable-en 目录
则此时跳出之前已选定的en限定符 直接淘汰drawable-en-sw360 开始从en的下一个限定符(sw)进行匹配
	>drawable-en-sw360/（淘汰）  
drawable-sw320/  

6. 例如： 
    - 在匹配屏幕尺寸（注意是尺寸 不是密度）时，如果没有匹配到，则会使用小于当前屏幕设计的资源。但是如果唯一可用的资源大于当前屏幕(比如没有drawable这种)，系统将不会使用这些资源，将会崩溃。  
    
	在此示例中 设备尺寸为300dp 不满足最小的sw320 又不存在drawable这种不限定的文件夹 则直接崩溃
	>drawable-sw320/（淘汰）  
drawable-sw360/（淘汰）  
drawable-sw400/（淘汰）
##限定符在dimens适配中的规则及建议
  - 在vivo生产的常见机型中 屏幕分为以下几类:

   1. 800*480  854*480  低分辨率的老机器，屏幕密度1.5 横向宽度320dp 
   2. 960*540  中低分辨率老机器，屏幕密度1.5  横向宽度360dp
   3. 1080*720  中分辨率机器  屏幕密度2 横向宽度360dp
   4. 1920*1080  高分辨率   屏幕密度3 横向宽度360dp
   5. 2540*1440  超高分辨率   屏幕密度4 横向宽度360dp

    一般来讲 UI输出的标注图一般会按照1080分辨率进行标注
 - 常见的适配规则是使用屏幕密度进行区分适配  
    - 比如，项目中内置 hdpi  xhdpi xxhdpi  xxxhdpi 等密度限定文件夹
    - 以上述 vivo 的常见机型为例，所有常见机型涉及四种屏幕密度，看似刚好可以用四种密度的限定符来进行适配

    - 一般的做法是省略为两个限定符， 保留hdpi和xxhdpi，以xxhdpi为基准分辨率将测量到的dp 整体缩小  缩小的倍数为320/360 然后将得到的dp填入到hdpi中 这样来保证800*480的机器上能等比例的缩小显示内容

但是这么做了之后就会发现问题

 - 上述机型中有一个特例，那就是960*540的机器，这个机器符合hdpi标准，但是横向宽度却是360dp 也就是说在这个屏幕上使用的dp值应当和xxhdpi屏幕上是一致的。

 - 传统的解决方案就是新建一个 hdpi-960x540的value 文件夹，同时拷贝一份 xxhdpi 中的值到 hdpi-960x540 当中
 - 使用 smallestWidth 可以很好的解决该问题
##smallestWidth 简介
smallestWidth适配，或者叫sw限定符适配。指的是Android会识别屏幕可用高度和宽度的最小尺寸的dp值（其实就是手机的宽度值），然后根据识别到的结果去资源文件中寻找对应限定符的文件夹下的资源文件。

创建smallestWidth限定符文件夹一般如下图所示   
![](https://i.imgur.com/tIooH4J.png)  


使用这种方式编写dimens的最大好处就是可以不用在关心设备的屏幕密度了，而且这种方式在适配时有更大的宽容度。

以四种举出的vivo机型为例子，很容易可以区分为以下两种sw

>value-sw320  
value-sw360

那么理论上我们只需要创建这两个限定符文件夹就可以解决之前遇到的问题，但需要注意的是 smallestWidth 表示的是最小宽度，也就是说一台设备的宽度必须大于或者等于sw的数值才会匹配上，如果整个项目里面都没有找到这个数值的文件夹，就会出现崩溃（参照三-6中的描述）

因此建议建立一个默认的 value 文件夹来存储默认值防止崩溃，事实上我们只需要准备两个文件夹 

>value （将360dp为基准按照倍数为320/360的比例进行缩放的标注）  
>value-sw360（用来存放以1080分辨率UI标注图为基准的标注）

即可满足现有的需求

TIPS : 虽然以上两个文件夹可以覆盖目前所有已知的机型，但仍然存在某些例外情况，比如公司新开发的机型，或者一些可以设置屏幕宽度dp的机型，因此建议在有些地方使用动态获取屏幕宽度的方式计算出准确的值进行适配


