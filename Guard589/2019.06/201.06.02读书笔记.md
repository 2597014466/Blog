# 内存分配
## 目录:
[1. 内存连续分配的动态分区的分配策略 ](#1)

[2. 基本分页存储管理方式](#2)

[3. 基本分段存储管理方式](#3)

[4. 虚拟内存](#4)

[5. 页面置换算法](#5)

###  <span id = "1">**1. 内存连续分配的动态分区的分配策略**</span>

首次适应(First  Fit)算法：空闲分区以地址递增的次序链接。分配内存时顺序查找，找到大小能满足要求的第一个空闲分区。

- 最佳适应(Best  Fit)算法：空闲分区按容量递增形成分区链，找到第一个能满足要求的空闲分区。

- 最坏适应(Worst  Fit)算法：又称最大适应(Largest Fit)算法，空闲分区以容量递减的次序链接。找到第一个能满足要求的空闲分区，也就是挑选出最大的分区。

###  <span id = "2">**2. 基本分页存储管理方式：**</span>

- 基本的地址变换机构
>从地址中分析出页号后，地址映射只需要把页号改为对应物理块号，偏移不变，即可找到内存中实际位置。一次指令需两次内存访问。
>每条指令用基地址+偏移量即可找到其物理存放的地址。

- 具有快表的地址变换机构
>基本分页机制下，一次指令需两次内存访问，处理机速度降低1/2，分页空间效率的提高以如此的速度为代价，得不偿失。
>改进：减少第1步访问内存的时间。增设一个具有“并行查询”能力的高速缓冲寄存器，称为“快表”，也称“联想寄存器”。

**在具有快表的分页机制中，地址的变换过程：**
- CPU给出逻辑地址后，由硬件进行地址转换并将页号送入高速缓存寄存器，并将此页号与快表中的所有页号进行比较。
如果找到匹配的页号，说明所要访问的页表项在快表中，则直接从中取出该页对应的页框号，与页内偏移量拼接形成物理地址。这样，存取数据仅一次访存便可实现。
- 如果没有找到，则需要访问主存中的页表，在读出页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换。

###  <span id = "3">**3. 基本分段存储管理方式：**</span>
分页管理方式是从计算机的角度考虑设计的，以提高内存的利用率，提升计算机的性能, 且分页通过硬件机制实现，对用户完全透明；而分段管理方式的提出则是考虑了用户和程序员，以满足方便编程、信息保护和共享、动态增长及动态链接等多方面的需要。

为了实现进程从逻辑地址到物理地址的变换功能，在系统中设置了段表寄存器，用于存放段表始址 F 和段表长度 M。其**从逻辑地址 A 到物理地址 E 之间的地址变换过程如下：**

从逻辑地址 A 中取出前几位为段号 S，后几位为段内偏移量 W。
比较段号 S 和段表长度 M，若 S 多 M，则产生越界中断，否则继续执行。
段表中段号 S 对应的段表项地址 = 段表起始地址 F + 段号 S * 段表项长度，取出该段表项的前几位得到段长 C。若段内偏移量>=C，则产生越界中断，否则继续执行。
取出段表项中该段的起始地址 b，计算 E = b + W，用得到的物理地址 E 去访问内存。

**分段分页的比较**
- 页是信息的物理单位,是出于系统内存利用率的角度提出的离散分配机制;
- 段是信息的逻辑单位,每个段含有一组意义完整的信息,是出于用户角度提出的内存管理机制.
- 页的大小是固定的,由系统决定;段的大小是不确定的,由用户决定.

###  <span id = "4">**4. 虚拟内存：**</span>

系统为用户提供了一个比实际内存大得多的存储器，称为虚拟存储器。

**虚拟存储器主要特征：**
1. 多次性，是指无需在作业运行时一次性地全部装入内存，而是允许被分成多次调入内存运行。
2. 对换性，是指无需在作业运行时一直常驻内存，而是允许在作业的运行过程中，进行换进和换出。
3. 虚拟性，是指从逻辑上扩充内存的容量，使用户所看到的内存容量，远大于实际的内存容量。

###  <span id = "5">**5. 页面置换算法：**</span>
### [操作系统之页面置换算法](https://www.cnblogs.com/fkissx/p/4712959.html)

1. 最佳置换算法(OPT)
最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。
最佳置换算法可以用来评价其他算法。
2. 先进先出置换算法（FIFO）：是最简单的页面置换算法。这种算法的基本思想是：当需要淘汰一个页面时，总是选择驻留主存时间最长的页面进行淘汰，即先进入主存的页面先淘汰。其理由是：最早调入主存的页面不再被使用的可能性最大。 
3. 最近最久未使用（LRU）算法：这种算法的基本思想是：利用局部性原理，根据一个作业在执行过程中过去的页面访问历史来推测未来的行为。它认为过去一段时间里不曾被访问过的页面，在最近的将来可能也不会再被访问。所以，这种算法的实质是：当需要淘汰一个页面时，总是选择在最近一段时间内最久不用的页面予以淘汰。 
