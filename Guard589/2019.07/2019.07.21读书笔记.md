## 代码整洁之道：
### 第七章：

**1. 使用异常而非返回码：**
- 返回错误码，会搞乱调用者的代码。调用者必须在调用之后即可检查错误。遇到错误时，最好抛出一个异常。调用代码很整洁，其逻辑不会被错误处理搞乱。

**2. 先写 Try-Catch-Finally 语句：**
- 异常的妙处是，它们在程序中定义了一个范围。执行 try-catch-finally 语句中 try 部分的代码时，你是在表明可随时取消执行，并在 catch 语句中接续。
- 在某种意义上，try 代码块就像是事务。 catch 代码块将程序维持在一种持续状态，无论 try 代码块中发生了什么均如此。所以，在编写可能抛出异常的代码时，最好先写出 try-catch-finally 语句。这能帮你定义代码的用户应该期待什么，无论 try 代码块中执行的代码出什么错都一样。
- 尝试编写强行抛出异常的测试，再往处理器中添加行为，使之满足测试要求。结果就是你要先构造 try 代码块的事务范围，而且也会帮助你维护好该范围的事务特征。
- 工作中异常处理常见的基本上就两种if else和 try catch。个人用到的主要是if else，但是使用if else处理异常，一般需要事先知道所有的异常，然后做出相应处理，如果异常类型比较多，有可能会出现考虑不到的情况，这时就有可能出问题。这种情况下，使用 try catch 反而会使代码更健壮。所以至于最终选择何种方式处理异常，依据业务场景来定，或许更合适。即根据不同的业务情景，细化异常的种类, 而不是一个catch exception 捕获所有的异常，如下：
```
do {
    //需要捕获异常的代码
       print("Hello World")
} catch xxxxx {
   //异常类型一
} catch xxxxx {
   //异常类型二
} catch xxxxx {
   //异常类型三
} catch{
   //其他
}
```

**3. 使用不可控异常：**
- 在 java 中可以捕获的异常（Exception 类的子类）分为可控式异常和运行时异常量两种类型。

**4. 给出异常发生的环境说明：**
- 你抛出的每个异常，都应当提供足够的环境说明，以便判断错误的来源和处所。
- 在 java 中，你可以从任何异常里得到堆栈踪迹（stack trace）；然而，堆栈踪迹却无法告诉你该失败操作的初衷。
- 应创建信息充分的错误信息，并和异常一起传递出去。在消息中，包括失败的操作和失败类型。如果你的应用程序有日志系统，传递足够的信息给 catch 块，并记录下来。

**5. 依调用者需要定义异常类：**
- 将第三方 API 打包是个良好的实践手段。当你打包一个第三方 API ，你就降低了对它的依赖：未来你可以不太痛苦地改用其他代码库。在你测试自己的代码时，打包也有助于模拟第三方调用。

**6. 别返回 null值:**
- 返回 null 值容易引发错误。
- 如果打算在方法中返回 null 值，不如抛出异常，或是返回特例对象。如果在调用某个第三方 API 中可能返回 null 值的方法，可以考虑用新方法打包这个方法，在新方法中抛出异常或返回特例对象。
- Java 有 Collections.emptyList() 方法，改方法返回一个预定义不可变列表，可用于生成空列表（特例对象）。这样编码，就能尽量避免 NullPointerException 的出现，代码也就更整洁了。

**7. 别传递 null 值:**
- 在方法中返回 null 值是糟糕的做法，但将 null 值传递给其他方法就更糟糕了。除非 API 要求你向它传递 null 值，否则就要尽可能避免传递 null 值。
　　
