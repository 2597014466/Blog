﻿# Android 开发中的依赖注入## 简介 > 在软件工程领域，依赖注入（Dependency Injection）是用于实现控制反转（Inversion of Control）的最常见的方式之一。##为什么需要依赖注入 > 引入依赖注入主要作用是用于解耦，解谁的耦呢？下面先看一个例子```public class MovieLister {    private MovieFinder finder;    public MovieLister() {        finder = new MovieFinderImpl();    }        public Movie[] moviesDirectedBy(String arg) {        List allMovies = finder.findAll();        for (Iterator it = allMovies.iterator(); it.hasNext();) {            Movie movie = (Movie) it.next();            if (!movie.getDirector().equals(arg)) it.remove();        }        return (Movie[]) allMovies.toArray(new Movie[allMovies.size()]);    }    ...public interface MovieFinder {    List findAll();}```### 说明 > 我们创建了一个名为 MovieLister 的类来提供需要的电影列表，它 moviesDirectedBy 方法提供根据导演名来搜索电影的方式。真正负责搜索电影的是实现了 MovieFinder 接口的 MovieFinderImpl，我们的 MovieLister 类在构造函数中创建了一个 MovieFinderImpl 的对象。但是，当我们希望修改 finder，将 finder 替换为一种新的实现时（比如为 MovieFinder 增加一个参数表明 Movie 数据的来源是哪个数据库），我们不仅需要修改 MovieFinderImpl 类，还需要修改我们 MovieLister 中创建 MovieFinderImpl 的代码。### 结论 > 通过上面例子可以看出，依赖类和被依赖类这就是依赖注入要处理的耦合。这种在 MovieLister 中创建 MovieFinderImpl 的方式，使得 MovieLister 不仅仅依赖于MovieFinder 这个接口，它还依赖于 MovieListImpl 这个实现。## 依赖注入的实现方式 > 实现依赖注入主要有三种实现方式 - 构造函数注入（Contructor Injection） > 这是我认为的最简单的依赖注入方式，我们修改一下上面代码中 MovieList 的构造函数，使得 MovieFinderImpl 的实现在 MovieLister 类之外创建。这样，MovieLister 就只依赖于我们定义的 MovieFinder 接口，而不依赖于 MovieFinder 的实现了。```public class MovieLister {    private MovieFinder finder;    public MovieLister(MovieFinder finder) {        this.finder = finder;    }    ...}``` -  setter注入 > 类似的，我们可以增加一个 setter 函数来传入创建好的 MovieFinder 对象，这样同样可以避免在 MovieFinder 中 hard init 这个对象。```public class MovieLister {    s...    public void setFinder(MovieFinder finder) {        this.finder = finder;    }}``` -  接口注入 > 接口注入使用接口来提供setter方法，其实现方式如下。首先要创建一个注入使用的接口。```public interface InjectFinder {    void injectFinder(MovieFinder finder);}``` > 之后，我们让MovieLister实现这个接口。```class MovieLister implements InjectFinder {    ...    public void injectFinder(MovieFinder finder) {      this.finder = finder;    }    ...}```## 总结说明 > 依赖注入降低了依赖和被依赖类型间的耦合，在修改被依赖的类型实现时，不需要修改依赖类型的实现，同时，对于依赖类型的测试，可以更方便的使用 mocking object 替代原有的被依赖类型，以达到对依赖对象独立进行单元测试的目的。最后需要注意的是，依赖注入只是控制反转的一种实现方式。控制反转还有一种常见的实现方式称为依赖查找。